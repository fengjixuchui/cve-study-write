// [+] related code

// [+] 获取某个Item相应的指针
PITEM MNLookUpItem(
    PMENU pMenu,	// [+] 从哪个菜单找
    UINT wCmd,		// [+] ID(0) 或 index(1)
    BOOL fByPosition,	// [+] 如果是0, 以index方式进行查找
    PMENU *ppMenuItemIsOn)	// [+] 返回在哪一个菜单找到的
{
    PITEM pItem;
    PITEM pItemRet = NULL;
    PITEM  pItemMaybe;
    PMENU   pMenuMaybe = NULL;
    int i;

    if (ppMenuItemIsOn != NULL)
        *ppMenuItemIsOn = NULL;

	// [+] Menu不能为空指针
	// [+] cItems不能为1
	// [+] wCmd != MFMWFP_NOITEM 
    if (pMenu == NULL || !pMenu->cItems || wCmd == MFMWFP_NOITEM) 
	{
//      RIPERR0(ERROR_INVALID_PARAMETER, RIP_WARNING, "MNLookUpItem: invalid item");
        return NULL;
    }

    /*
     * dwFlags determines how we do the search
     */
    // [+] 如果fByPosition来获取, 则直接从数组当中根绝Index来获取值
    if (fByPosition) 
	{
        if (wCmd < (UINT)pMenu->cItems) 
		{
            pItemRet = &((PITEM)REBASEALWAYS(pMenu, rgItems))[wCmd];	
            if (ppMenuItemIsOn != NULL)
                *ppMenuItemIsOn = pMenu;
            return (pItemRet);
        } else
            return NULL;
    }
    /*
     * Walk down the menu and try to find an item with an ID of wCmd.
     * The search procedes from the end of the menu (as was done in
     * assembler).
     */

/* this is the Chicago code, which walks from the front of the menu -- Fritz */


	// [+] 否则根据wID来进行查找
//        for (pItem = &pMenu->rgItems[i - 1]; pItemRet == NULL && i--; --pItem) {
    for (i = 0, pItem = REBASEALWAYS(pMenu, rgItems); i < (int)pMenu->cItems;	// [+] 否者递归查找
            i++, pItem++) 
	{

        /*
         * If the item is a popup, recurse down the tree
         */
        if (pItem->spSubMenu != NULL)
		{
        //
        // COMPAT:
        // Allow apps to pass in menu handle as ID in menu APIs.  We
        // remember that this popup had a menu handle with the same ID
        // value.  This is a 2nd choice though.  We still want to see
        // if there's some actual command that has this ID value first.
        //
            if (pItem->wID == wCmd) 	// [+] ID相等
			{
                pMenuMaybe = pMenu;
                pItemMaybe = pItem;
            }

            pItemRet = MNLookUpItem((PMENU)REBASEPTR(pMenu, pItem->spSubMenu),
                    wCmd, FALSE, ppMenuItemIsOn);	// [+] 如果子菜单当中找到了 那么就范围子菜单当中的
                    								// [+] 否则就为本次找到的
            if (pItemRet != NULL)
                return pItemRet;
        } 
		else 
		if (pItem->wID == wCmd)	// [+] 没有子菜单 就根据ID来判断
		{	// [+] 这个地方怎么才能进入呢

                /*
                 * Found the item, now save things for later
                 */
                if (ppMenuItemIsOn != NULL)
                    *ppMenuItemIsOn = pMenu;
                return pItem;
        }
    }

    if (pMenuMaybe) 	// [+] 返回结果
	{
        // no non popup menu match found -- use the 2nd choice popup menu
        // match
        if (ppMenuItemIsOn != NULL)
            *ppMenuItemIsOn = pMenuMaybe;
        return(pItemMaybe);
    }

    return(NULL);
}


------ ---------------   ------

BOOL xxxInsertMenuItem(
#else
BOOL _InsertMenuItem(	// [+] 这份代码存在一个漏洞	
#endif // MEMPHIS_MENUS
    PMENU pMenu,		// [+] pMenu 进行插入操作的Menu对象的指针
    UINT wIndex,		// [+] 选择在哪个位置进行插入操作
    BOOL fByPosition,	// [+] 是根据Index还是根据ID
    LPMENUITEMINFOW lpmii,
    PUNICODE_STRING pstrItem)
{
    PITEM pItem;

    PMENU           pMenuItemIsOn;
    PITEM           pNewItems;
#ifdef MEMPHIS_MENUS
    PPOPUPMENU      ppopup;
    TL              tlMenu;

    CheckLock(pMenu);
#endif // MEMPHIS_MENUS
// Find out where the item we are inserting should go.
    if (wIndex != MFMWFP_NOITEM) 
	{ 
        pItem = MNLookUpItem(pMenu, wIndex, fByPosition, &pMenuItemIsOn);	// [+] 我们可以传入wIndex == -1. 然后通过后面的操作使其变为非 -1 ??? 是这个意思么?

        if (pItem != NULL)
            pMenu = pMenuItemIsOn;	// [+] 这个地方才是最重要的... 如果没有替换的话 那么很容易出错
        else 
		{
            wIndex = MFMWFP_NOITEM;	// [+] 否则说明此Item不存在 也是MFMWFP_NOITEM的意思
        }
    }
        pItem = NULL;
#ifdef MEMPHIS_MENUS
    if (pMenu->cItems && (!(lpmii->fMask & MIIM_BITMAP) || (lpmii->hbmpItem >= (HBITMAP)MENUHBM_MAX)))	// [+] 接着这个If else语句是为了做什么来着
#else // MEMPHIS_MENUS
    if (pMenu->cItems && (!(lpmii->fType & MFT_BITMAP) || (lpmii->dwTypeData >= (LPWSTR)MENUHBM_MAX)))
#endif // MEMPHIS_MENUS
    {
        // keep normal menu items between the MDI system bitmap items
        UINT wSave, w;	// [+] w代表什么意思
        PITEM  pItemWalk;
        wSave = w = wIndex;

        if (pItem && !fByPosition)
            w = ((PBYTE)pItem - (PBYTE)(pMenu->rgItems)) / sizeof(ITEM);	// [+] 一共有多少项

        if (!w)	// [+] 这个地方判断是否为第一项
        {
            pItemWalk = pMenu->rgItems;	// [+] 直接获取第一项的值
#ifdef MEMPHIS_MENUS
            if ((pItemWalk->hbmp == (HBITMAP)MENUHBM_SYSTEM))
#else // MEMPHIS_MENUS
            if ((pItemWalk->fType & MFT_BITMAP) && (pItemWalk->hTypeData == (HANDLE)MENUHBM_SYSTEM))
#endif //MEMPHIS_MENUS
                wIndex = 1;	// [+] 设置为1
        }
        else
        {
            if (w == MFMWFP_NOITEM)
                w = pMenu->cItems;

            w--;	// [+] 否者的话是由很多项
            pItemWalk = pMenu->rgItems + w;
#ifdef MEMPHIS_MENUS
            while (w && (pItemWalk->hbmp) && (pItemWalk->hbmp < (HBITMAP)MENUHBM_MAX))	// [+] 这个地方是为了查找什么呢
#else // MEMPHIS_MENUS
            while (w && (pItemWalk->fType & MFT_BITMAP) && (pItemWalk->hTypeData < (HANDLE)MENUHBM_MAX))

#endif // MEMPHIS_MENUS
            {
                wIndex = w--;
                pItemWalk--;
            }
        }

        if (wIndex != wSave)	// [+] 如果不一样的话 说明我们需要替换pItem
            pItem = pMenu->rgItems + wIndex;
    }

    // LATER -- we currently realloc every 10 items.  investigate the
    // performance hit/gain we get from this and adjust accordingly.
    if (pMenu->cItems >= pMenu->cAlloced)	// [+] a. cItem是现在有的对象 b. cAlloced是总共能够填充的对象
	{										// [+] 可以去创建一个简单的菜单 看下会分配几个对象
        if (pMenu->rgItems) 	// [+] 如果pMenu->rgItems是存在的
		{
            pNewItems = (PITEM)DesktopAlloc(pMenu->head.rpdesk->hheapDesktop,	// [+] 如果是不是第一次的话 就重新分配一个更大的
                    (pMenu->cAlloced + CMENUITEMALLOC) * sizeof(ITEM));
            if (pNewItems) 
			{
                RtlCopyMemory(pNewItems, pMenu->rgItems,
                        pMenu->cAlloced * sizeof(ITEM));	// [+] 则分配到那里去即可
#ifdef DEBUG
                if (gfTrackLocks) 
				{
                    RelocateMenuLockRecords(pNewItems, pMenu->cItems,
                        ((PBYTE)pNewItems) - (PBYTE)(pMenu->rgItems));
                }
#endif
                DesktopFree(pMenu->head.rpdesk->hheapDesktop, pMenu->rgItems);	// [+] 释放相应的堆
            }
        } 
		else 
        {
            pNewItems = (PITEM)DesktopAlloc(pMenu->head.rpdesk->hheapDesktop,	// [+] 我在思考一个问题 当这个地方初始化之后 能不能通过回到用户层去 然后获取泄露的数据
                    sizeof(ITEM) * CMENUITEMALLOC);
        }

        if (pNewItems == NULL)
            return(FALSE);

        pMenu->cAlloced += CMENUITEMALLOC;	// [+] 这个地方扩大
        pMenu->rgItems = pNewItems;	// [+] 重新定义... 我怎么... 觉得这个地方有一个... 未初始化漏洞

        /*
         * Now look up the item again since it probably moved when we realloced the
         * memory.
         */
        if (wIndex != MFMWFP_NOITEM)
            pItem = MNLookUpItem(pMenu, wIndex, fByPosition, &pMenuItemIsOn);	// [+] 需要使用我们的程序流使其执行到这里

    }
    pMenu->cItems++;	// [+] 这个地方加一

    if (pItem != NULL) {
        // Move this item up to make room for the one we want to insert.
        memmove(pItem + 1, pItem, (pMenu->cItems - 1) *	sizeof(ITEM) - ((char *)pItem - (char *)pMenu->rgItems));	// pItem进行填充, 然后把剩余的部分放进去
#ifdef DEBUG
        if (gfTrackLocks) {
            RelocateMenuLockRecords(pItem + 1,
                    &(pMenu->rgItems[pMenu->cItems]) - (pItem + 1),
                    sizeof(ITEM));
        }
#endif
    } 
	else 
	{

        // If lpItem is null, we will be inserting the item at the end of the
        // menu.
        pItem = pMenu->rgItems + pMenu->cItems - 1;	// [+] 如果pItem为NULL. 则从末尾进行插入
    }

    // Need to zero these fields in case we are inserting this item in the
    // middle of the item list.
	// [+] 初始化
    pItem->fType           = 0;
    pItem->fState          = 0;
    pItem->wID             = 0;
    pItem->spSubMenu       = NULL;
    pItem->hbmpChecked     = NULL;
    pItem->hbmpUnchecked   = NULL;
    pItem->hTypeData       = NULL;
    pItem->cch             = 0;
    pItem->dwItemData      = 0;
    pItem->xItem           = 0;
    pItem->yItem           = 0;
    pItem->cxItem          = 0;
    pItem->cyItem          = 0;
#ifdef MEMPHIS_MENUS
    pItem->hbmp            = NULL;
    pItem->cxBmp           = -1;
    pItem->cyBmp           = -1;
    pItem->lpstr           = NULL;
    if (ppopup = MNCheckMenuUp(pMenu))
    {
        // this menu is currently being displayed -- increment the selection
        // pos if it is after the point of insertion
        // [+] 这个地方的逻辑没看的太懂 为什么需要我们进行挪移操作
        if (ppopup->posSelectedItem >=
            (int) ((pItem - pMenu->rgItems) / sizeof(ITEM)) )
            ppopup->posSelectedItem++;
    }
    ThreadLock(pMenu, &tlMenu);
    if (!xxxSetLPITEMInfo(pMenu, pItem, lpmii, pstrItem)) {		// [+] 这个地方是具体的填充
#else
    if (!SetLPITEMInfo(pMenu, pItem, lpmii, pstrItem)) 	// [+] 这个地方进行分析
	{
#endif // MEMPHIS_MENUS
        MNFreeItem(pMenu, pItem, TRUE);	// [+] 释放Items


        // Move things up since we removed/deleted the item
        // [+] 如果失败的话我们需要把他给移动回去
        memmove(pItem, pItem + 1, pMenu->cItems * (UINT)sizeof(ITEM) + (UINT)((char *)&pMenu->rgItems[0] - (char *)(pItem + 1)));	// [+] 这个地方为什么要再来一次
#ifdef DEBUG
        if (gfTrackLocks) {
            RelocateMenuLockRecords(pItem,
                    &(pMenu->rgItems[pMenu->cItems - 1]) - pItem,
                    -(int)sizeof(ITEM));
        }
#endif
        pMenu->cItems--;	// [+] 失败的话就减一下
#ifdef MEMPHIS_MENUS
        ThreadUnlock(&tlMenu);
#endif // MEMPHIS_MENUS
        return(FALSE);
	}

#ifdef MEMPHIS_MENUS
    ThreadUnlock(&tlMenu);	// [+] 解锁
#endif // MEMPHIS_MENUS
    return(TRUE);

}



void _SetMenuItemInfoStruct(
    UINT wFlags,
    UINT wIDNew,
    LPCWSTR lpszNew,
    LPMENUITEMINFO pmii,
    PUNICODE_STRING pstr)
{
#ifdef MEMPHIS_MENUS
    pmii->fMask = MIIM_STATE | MIIM_ID | MIIM_FTYPE;
#else // MEMPHIS_MENUS
    pmii->fMask = MIIM_STATE | MIIM_ID | MIIM_TYPE;

#endif // MEMPHIS_MENUS
    if (wFlags & MF_POPUP) {
        pmii->fMask |= MIIM_SUBMENU;
        pmii->hSubMenu = (HMENU)wIDNew;
    }

    if (wFlags & MF_OWNERDRAW) {
        pmii->fMask |= MIIM_DATA;
        pmii->dwItemData = (DWORD) lpszNew;
    }

    pmii->fState      = wFlags & MFS_OLDAPI_MASK;
    pmii->fType       = wFlags & MFT_OLDAPI_MASK;
    pmii->wID         = wIDNew;
    pmii->dwTypeData  = (LPWSTR) lpszNew;
#ifdef MEMPHIS_MENUS
    if (wFlags & MIIM_STRING)
#else // MEMPHIS_MENUS
    if (!(pmii->fType & MFT_NONSTRING))
#endif // MEMPHIS_MENUS
        RtlInitUnicodeString(pstr, lpszNew);
}
